<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>MuGen Wallpaper — Web wallpaper demo 1</title>
    <meta
      name="description"
      content="Demo page generated by MuGen Wallpaper showing a web wallpaper setup. This demo is intended for GitHub Pages hosting."
    />
    <link
      rel="canonical"
      href="https://dreaminghk.github.io/mugenwallpaper-demo1/demo.html"
    />

    <!-- Open Graph: improves link previews on social platforms -->
    <meta property="og:site_name" content="MuGen Wallpaper Demo" />
    <meta
      property="og:title"
      content="MuGen Wallpaper — Web wallpaper demo 1"
    />
    <meta
      property="og:description"
      content="Demo page generated by MuGen Wallpaper showing a web wallpaper setup."
    />
    <meta property="og:type" content="website" />
    <meta
      property="og:url"
      content="https://dreaminghk.github.io/mugenwallpaper-demo1/demo.html"
    />
    <!-- Optional thumbnail if you add one later -->
    <!-- <meta property="og:image" content="/path/to/thumbnail.png"> -->

    <!-- Twitter Card -->
    <meta name="twitter:card" content="summary_large_image" />
    <meta
      name="twitter:title"
      content="MuGen Wallpaper — Web wallpaper demo 1"
    />
    <meta
      name="twitter:description"
      content="Demo page generated by MuGen Wallpaper showing a web wallpaper setup."
    />

    <!-- GitHub Pages / browser theming -->
    <meta name="theme-color" content="#000000" />

    <!-- Generator and attribution (kept in metadata and comments) -->
    <meta
      name="generator"
      content="MuGen Wallpaper (https://www.mugenwallpaper.com)"
    />

    <!-- Structured data (hidden from rendered page) -->
    <script type="application/ld+json">
      {
        "@context": "https://schema.org",
        "@type": "WebPage",
        "name": "MuGen Wallpaper — Web wallpaper demo 1",
        "description": "Demo page generated by MuGen Wallpaper showing a web wallpaper setup.",
        "url": "https://dreaminghk.github.io/mugenwallpaper-demo1/demo.html",
        "creator": {
          "@type": "Organization",
          "name": "MuGen Wallpaper",
          "url": "https://www.mugenwallpaper.com"
        }
      }
    </script>

    <!-- Hidden developer information: will not display in video or page UI -->
    <!--
		Source: MuGen Wallpaper demo repository
		Repo: https://github.com/dreaminghk/mugenwallpaper-demo1
		Creator: dreaminghk
		Generated: 2025-09-14
		License: Please see the original assets and MuGen Wallpaper license on https://www.mugenwallpaper.com
		Notes: Keep these comments for attribution. They are only visible in page source.
	-->
  </head>
  <body>
    <style>
      /* Make the page and #element fill the viewport with no margin/padding */
      html,
      body {
        height: 100%;
        margin: 0;
        padding: 0;
      }

      /* Use blue_sky.jpg as a full-screen responsive background while preserving aspect ratio */
      body {
        background-image: url('blue_sky.jpg');
        background-size: cover; /* scale the image to cover the viewport while keeping aspect ratio */
        background-position: center center; /* center the image */
        background-repeat: no-repeat;
        background-attachment: fixed; /* optional: keeps background fixed during scroll */
        /* fallback background color while image loads */
        background-color: #000;
      }

      /* Keep #element full viewport and transparent so background shows through */
      #element {
        width: 100vw;
        height: 100vh;
        overflow: hidden;
        display: block;
        background: transparent;
      }
    </style>

    <div id="element"></div>

    <!-- Fullscreen transparent canvas for physically-inspired volumetric clouds (WebGL) -->
    <canvas id="clouds" aria-hidden="true"></canvas>

    <script>
      // WebGL volumetric clouds: physically-inspired single-scattering with advection
      (function () {
        const canvas = document.getElementById('clouds');
        // Request a WebGL context with alpha and without premultiplied alpha to simplify blending
        const gl = canvas.getContext('webgl', { alpha: true, antialias: true, premultipliedAlpha: false });
        if (!gl) return; // WebGL not available

        // resize handling
        function resize() {
          // Render at reduced resolution for performance (scaled up via CSS)
          const targetDPR = 1.0;     // cap device pixel ratio for speed
          const renderScale = 0.66;  // render ~66% of viewport resolution for 120Hz
          const device = Math.max(1, window.devicePixelRatio || 1);
          const dpr = Math.min(device, targetDPR) * renderScale;
          const w = Math.floor(window.innerWidth * dpr);
          const h = Math.floor(window.innerHeight * dpr);
          if (canvas.width !== w || canvas.height !== h) {
            canvas.width = w;
            canvas.height = h;
            canvas.style.width = window.innerWidth + 'px';
            canvas.style.height = window.innerHeight + 'px';
            gl.viewport(0, 0, w, h);
          }
        }

        // Make canvas full-screen and on top of background but behind UI
        Object.assign(canvas.style, {
          position: 'fixed',
          left: '0',
          top: '0',
          width: '100vw',
          height: '100vh',
          pointerEvents: 'none',
          zIndex: 1,
        });
        // ensure CSS background is transparent in case user-agent paints a default
        canvas.style.background = 'transparent';

        // vertex shader (simple passthrough)
        const vsSource = `
          attribute vec2 a_pos;
          varying vec2 v_uv;
          void main() {
            v_uv = a_pos * 0.5 + 0.5;
            gl_Position = vec4(a_pos, 0.0, 1.0);
          }
        `;

        // fragment shader: volumetric single-scattering through a 2.5D cloud layer
        const fsSource = `
          precision highp float;
          varying vec2 v_uv;
          uniform float u_time;
          uniform vec2 u_resolution;
          uniform vec2 u_wind;
          uniform vec3 u_sunDir;      // normalized sun direction (from sky to scene)
          uniform vec3 u_sunColor;    // sunlight color
          uniform float u_coverage;   // base coverage threshold [0..1]
          uniform float u_density;    // density scale
          uniform float u_thickness;  // cloud layer thickness in arbitrary units
          uniform float u_scale;      // spatial frequency scale
          uniform float u_lightAbsorption; // how quickly light is absorbed

          const bool FAST_MODE = true; // ultra-fast 2D lighting approximation for 120Hz

          // Hash helpers
          float hash(vec2 p) { return fract(sin(dot(p, vec2(127.1, 311.7))) * 43758.5453123); }
          float hash3(vec3 p) { return fract(sin(dot(p, vec3(127.1, 311.7, 74.7))) * 43758.5453123); }

          // 2D value noise
          float noise(vec2 p) {
            vec2 i = floor(p);
            vec2 f = fract(p);
            // four corners
            float a = hash(i);
            float b = hash(i + vec2(1.0, 0.0));
            float c = hash(i + vec2(0.0, 1.0));
            float d = hash(i + vec2(1.0, 1.0));
            vec2 u = f * f * (3.0 - 2.0 * f);
            return mix(a, b, u.x) + (c - a) * u.y * (1.0 - u.x) + (d - b) * u.x * u.y;
          }

          // 3D value noise
          float noise3(vec3 p) {
            vec3 i = floor(p);
            vec3 f = fract(p);
            float n000 = hash3(i + vec3(0.0, 0.0, 0.0));
            float n100 = hash3(i + vec3(1.0, 0.0, 0.0));
            float n010 = hash3(i + vec3(0.0, 1.0, 0.0));
            float n110 = hash3(i + vec3(1.0, 1.0, 0.0));
            float n001 = hash3(i + vec3(0.0, 0.0, 1.0));
            float n101 = hash3(i + vec3(1.0, 0.0, 1.0));
            float n011 = hash3(i + vec3(0.0, 1.0, 1.0));
            float n111 = hash3(i + vec3(1.0, 1.0, 1.0));
            vec3 u = f * f * (3.0 - 2.0 * f);
            float nx00 = mix(n000, n100, u.x);
            float nx10 = mix(n010, n110, u.x);
            float nx01 = mix(n001, n101, u.x);
            float nx11 = mix(n011, n111, u.x);
            float nxy0 = mix(nx00, nx10, u.y);
            float nxy1 = mix(nx01, nx11, u.y);
            return mix(nxy0, nxy1, u.z);
          }

          // Fractal Brownian Motion (2D)
          float fbm(vec2 p) {
            float v = 0.0;
            float a = 0.5;
            mat2 m = mat2(1.6, 1.2, -1.2, 1.6);
            for (int i = 0; i < 5; i++) {
              v += a * noise(p);
              p = m * p * 1.9;
              a *= 0.5;
            }
            return v;
          }

          // Fractal Brownian Motion (3D) — reduced octaves for performance
          float fbm3(vec3 p) {
            float v = 0.0;
            float a = 0.5;
            mat3 m = mat3( 1.6,  1.2,  0.0,
                           -1.2,  1.6,  0.0,
                            0.0,  0.0,  1.7);
            for (int i = 0; i < 4; i++) {
              v += a * noise3(p);
              p = m * p * 1.8 + 0.1;
              a *= 0.5;
            }
            return v;
          }

          // Simple curl-like warp from 2D FBM gradients to add turbulence
          vec2 domainWarp(vec2 p) {
            // Reduced warp for less "wavy" motion
            float e = 0.06;
            float n1 = fbm(p * 0.9);
            float n2 = fbm((p + vec2(5.2, 1.3)) * 0.9);
            // pseudo curl by swapping gradients
            return e * vec2(n2 - n1, n1 - n2);
          }

          // Henyey-Greenstein phase (simplified)
          float hgPhase(float cosTheta, float g) {
            float g2 = g * g;
            float denom = pow(1.0 + g2 - 2.0 * g * cosTheta, 1.5);
            return (1.0 - g2) / (4.0 * 3.14159265 * denom);
          }

          // Fast 2D approximation path: single-pass, no raymarch
          vec4 fastClouds(vec2 uv, vec2 advect, vec2 aspect) {
            // Domain warp for turbulent structures
            vec2 warped = uv * u_scale + advect + domainWarp(uv * 0.5 + 0.02 * u_time);
            float base = fbm(warped * 1.3);
            float detail = fbm(warped * 2.2 + 13.7);
            float micro = fbm(warped * 4.0 + 31.1);
            float n = mix(base, detail, 0.30);
            n = mix(n, micro, 0.10);
            // Coverage and shaping (lighter overall)
            float d = smoothstep(u_coverage - 0.12, u_coverage + 0.06, n);
            d = pow(d, 1.25) * u_density; // lift highlights less, keep edges soft
            d = clamp(d, 0.0, 1.0);

            // Cheap directional self-shadowing: sample density along sun direction in screen space
            vec2 sd = normalize(vec2(u_sunDir.x, u_sunDir.y) + vec2(1e-5));
            sd *= 0.09; // smaller step reduces banding/waves
            float occ = 0.0;
            occ += smoothstep(u_coverage - 0.10, u_coverage + 0.10, fbm((warped + sd) * 1.4));
            occ += smoothstep(u_coverage - 0.10, u_coverage + 0.10, fbm((warped + sd*2.0) * 1.3)) * 0.6;
            occ += smoothstep(u_coverage - 0.10, u_coverage + 0.10, fbm((warped + sd*3.5) * 1.2)) * 0.35;
            float shadow = clamp(1.0 - occ * 0.38, 0.45, 1.0);

            // Lighting and color
            vec3 albedo = vec3(1.16, 1.16, 1.20);
            vec3 light = u_sunColor * (0.65 + 0.35 * shadow);
            vec3 color = albedo * light;
            float alpha = clamp(0.06 + 0.85 * d, 0.0, 1.0); // thinner overall opacity
            return vec4(color, alpha);
          }

          void main() {
            // Normalize pixel coordinates to world-like meters
            vec2 aspect = vec2(u_resolution.x / min(u_resolution.x, u_resolution.y),
                               u_resolution.y / min(u_resolution.x, u_resolution.y));
            vec2 uv = (v_uv * 2.0 - 1.0) * aspect; // centered coordinates

            float t = u_time;
            // Wind advection of the XY domain
            vec2 wind = u_wind;
            vec2 advect = wind * t;

            if (FAST_MODE) {
              gl_FragColor = fastClouds(uv, advect, aspect);
              return;
            }

            // Domain warp for turbulent eddies (volumetric path)
            vec2 warped = uv * u_scale + advect + domainWarp(uv * 0.6 + 0.1 * t);

            // Define a coverage mask used in volumetric density shaping
            float baseMask = fbm(uv * (0.9 * u_scale) + advect * 0.5);
            float cover = smoothstep(u_coverage - 0.08, u_coverage + 0.08, baseMask);

            // Raymarch parameters (vertical integration through layer)
            const int STEPS = 16;      // marching steps through the cloud thickness (lowered)
            const int LIGHT_STEPS = 5; // steps for light shadowing (lowered)
            float ds = u_thickness / float(STEPS);
            float heightBase = 0.0; // base height reference

            // Single scattering integration
            float transmittance = 1.0; // Beer-Lambert T
            vec3  radiance = vec3(0.0);

            // View direction assumed from above looking down; for wallpaper this is fine
            vec3 V = vec3(0.0, -1.0, 0.0);
            float cosTheta = clamp(dot(normalize(-V), normalize(u_sunDir)), -1.0, 1.0);
            float phase = hgPhase(cosTheta, 0.7);

            for (int i = 0; i < STEPS; i++) {
              float h = heightBase + (float(i) + 0.5) * ds; // sample at slice center
              // 3D FBM density field
              vec3 p = vec3(warped, h * 0.8 + 10.0);
              float base = fbm3(p);
              // Coverage threshold: shift noise so that only the upper tail forms clouds
              float d = smoothstep(u_coverage, 1.0, base);
              // Vertical shaping (more density near mid of the layer)
              float y = (float(i) + 0.5) / float(STEPS);
              float dome = exp(-4.0 * (y - 0.5) * (y - 0.5));
              d *= dome;
              d *= mix(0.6, 1.0, cover);
              d *= u_density;

              if (d > 0.001) {
                // Light attenuation along sun ray for soft self-shadow
                float lightT = 1.0;
                vec3 lp = p;
                float lds = (u_thickness * 0.8) / float(LIGHT_STEPS);
                vec3 ldir = normalize(u_sunDir);
                for (int j = 0; j < LIGHT_STEPS; j++) {
                  lp += ldir * lds;
                  float ld = smoothstep(u_coverage, 1.0, fbm3(lp));
                  float ly = float(j) / float(LIGHT_STEPS);
                  float ldome = exp(-4.0 * (ly - 0.2) * (ly - 0.2));
                  ld *= ldome * u_density;
                  lightT *= exp(-u_lightAbsorption * ld * lds);
                }

                // In-scattering from sunlight at this segment
                vec3 scatter = u_sunColor * phase * lightT * d * ds;

                // Apply view transmittance to accumulated radiance
                radiance += transmittance * scatter;
                // Update view transmittance by extinction
                transmittance *= exp(-d * ds);
                if (transmittance < 0.01) break;
              }
            }

            // Convert integrated result into color/alpha.
            // Alpha represents how much the cloud occludes background (1 - transmittance)
            float alpha = clamp(1.0 - transmittance, 0.0, 1.0);
            // Subtle bluish shadowing for thicker regions to match sky lighting
            vec3 cloudColor = mix(vec3(1.05), vec3(1.1, 1.1, 1.12), 0.2);
            vec3 color = cloudColor * radiance;

            gl_FragColor = vec4(color, alpha);
          }
        `;

        // utility: compile shader
        function compileShader(type, source) {
          const s = gl.createShader(type);
          gl.shaderSource(s, source);
          gl.compileShader(s);
          if (!gl.getShaderParameter(s, gl.COMPILE_STATUS)) {
            console.error('Shader compile error:', gl.getShaderInfoLog(s));
            gl.deleteShader(s);
            return null;
          }
          return s;
        }

        const vs = compileShader(gl.VERTEX_SHADER, vsSource);
        const fs = compileShader(gl.FRAGMENT_SHADER, fsSource);
        const prog = gl.createProgram();
        gl.attachShader(prog, vs);
        gl.attachShader(prog, fs);
        gl.bindAttribLocation(prog, 0, 'a_pos');
        gl.linkProgram(prog);
        if (!gl.getProgramParameter(prog, gl.LINK_STATUS)) {
          console.error('Program link error', gl.getProgramInfoLog(prog));
          return;
        }
  gl.useProgram(prog);
  // Enable alpha blending so clouds composite over the page background
  gl.enable(gl.BLEND);
  gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);

        // fullscreen triangle
        const quad = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, quad);
        const verts = new Float32Array([-1, -1, 3, -1, -1, 3]);
        gl.bufferData(gl.ARRAY_BUFFER, verts, gl.STATIC_DRAW);
        gl.enableVertexAttribArray(0);
        gl.vertexAttribPointer(0, 2, gl.FLOAT, false, 0, 0);

        // uniforms
        const u_time = gl.getUniformLocation(prog, 'u_time');
        const u_resolution = gl.getUniformLocation(prog, 'u_resolution');
        const u_wind = gl.getUniformLocation(prog, 'u_wind');
        const u_sunDir = gl.getUniformLocation(prog, 'u_sunDir');
        const u_sunColor = gl.getUniformLocation(prog, 'u_sunColor');
        const u_coverage = gl.getUniformLocation(prog, 'u_coverage');
        const u_density = gl.getUniformLocation(prog, 'u_density');
        const u_thickness = gl.getUniformLocation(prog, 'u_thickness');
        const u_scale = gl.getUniformLocation(prog, 'u_scale');
        const u_lightAbsorption = gl.getUniformLocation(prog, 'u_lightAbsorption');

        let start = performance.now();

        // Default physical-ish parameters
        const params = {
          coverage: 0.55,      // higher -> fewer/thinner clouds
          density: 0.9,        // lower opacity overall
          thickness: 1.2,      // kept for volumetric path
          scale: 0.3,         // spatial scale
          lightAbsorption: 1.5 // volumetric path only
        };

        function sunDirection(t) {
          // Slow cycle of sun over time; keep moderately high to avoid dark scene
          const floatTime = t * 0.02;
          const elev = 0.8 - 0.15 * Math.cos(floatTime * 0.2); // radians
          const azim = floatTime * 0.05;
          const x = Math.cos(elev) * Math.cos(azim);
          const y = Math.sin(elev);
          const z = Math.cos(elev) * Math.sin(azim);
          // Return vector from sun toward scene (downward)
          return [-x, -y, -z];
        }

        // Optional lightweight FPS cap to reduce GPU usage
        const targetFPS = 0; // 0 = unlimited (use monitor refresh)
        const minFrameTime = targetFPS > 0 ? 1.0 / targetFPS : 0.0;
        let lastRenderT = 0;

        function render() {
          resize();
          const now = performance.now();
          const t = (now - start) / 1000.0;
          if (minFrameTime > 0.0 && (t - lastRenderT) < minFrameTime) {
            requestAnimationFrame(render);
            return;
          }
          gl.clearColor(0, 0, 0, 0);
          gl.clear(gl.COLOR_BUFFER_BIT);
          gl.useProgram(prog);
          gl.uniform1f(u_time, t);
          gl.uniform2f(u_resolution, canvas.width, canvas.height);
          // Gentle varying wind with slight rotation over time
          // Use a stable, gentle wind to avoid "wavy" look
          const windSpeed = 0.006; // world units per second
          const windDir = [0.7, 0.2];
          const len = Math.hypot(windDir[0], windDir[1]) || 1.0;
          gl.uniform2f(u_wind, (windDir[0] / len) * windSpeed, (windDir[1] / len) * windSpeed);

          const sd = sunDirection(t);
          gl.uniform3f(u_sunDir, sd[0], sd[1], sd[2]);
          gl.uniform3f(u_sunColor, 1.0, 0.97, 0.92); // warm sunlight
          gl.uniform1f(u_coverage, params.coverage);
          gl.uniform1f(u_density, params.density);
          gl.uniform1f(u_thickness, params.thickness);
          gl.uniform1f(u_scale, params.scale);
          gl.uniform1f(u_lightAbsorption, params.lightAbsorption);
          gl.drawArrays(gl.TRIANGLES, 0, 3);
          lastRenderT = t;
          requestAnimationFrame(render);
        }

        // start
        resize();
        window.addEventListener('resize', resize);
        requestAnimationFrame(render);
      })();
    </script>

  </body>
</html>
