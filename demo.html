<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>MuGen Wallpaper — Web wallpaper demo 1</title>
    <meta
      name="description"
      content="Demo page generated by MuGen Wallpaper showing a web wallpaper setup. This demo is intended for GitHub Pages hosting."
    />
    <link
      rel="canonical"
      href="https://dreaminghk.github.io/mugenwallpaper-demo1/demo.html"
    />

    <!-- Preload local variable TTF for faster first paint -->
    <link
      rel="preload"
      href="NotoSansJP-VariableFont_wght.ttf"
      as="font"
      type="font/ttf"
      crossorigin
    />

    <!-- Open Graph: improves link previews on social platforms -->
    <meta property="og:site_name" content="MuGen Wallpaper Demo" />
    <meta
      property="og:title"
      content="MuGen Wallpaper — Web wallpaper demo 1"
    />
    <meta
      property="og:description"
      content="Demo page generated by MuGen Wallpaper showing a web wallpaper setup."
    />
    <meta property="og:type" content="website" />
    <meta
      property="og:url"
      content="https://dreaminghk.github.io/mugenwallpaper-demo1/demo.html"
    />
    <!-- Optional thumbnail if you add one later -->
    <!-- <meta property="og:image" content="/path/to/thumbnail.png"> -->

    <!-- Twitter Card -->
    <meta name="twitter:card" content="summary_large_image" />
    <meta
      name="twitter:title"
      content="MuGen Wallpaper — Web wallpaper demo 1"
    />
    <meta
      name="twitter:description"
      content="Demo page generated by MuGen Wallpaper showing a web wallpaper setup."
    />

    <!-- GitHub Pages / browser theming -->
    <meta name="theme-color" content="#000000" />

    <!-- Generator and attribution (kept in metadata and comments) -->
    <meta
      name="generator"
      content="MuGen Wallpaper (https://www.mugenwallpaper.com)"
    />

    <!-- Structured data (hidden from rendered page) -->
    <script type="application/ld+json">
      {
        "@context": "https://schema.org",
        "@type": "WebPage",
        "name": "MuGen Wallpaper — Web wallpaper demo 1",
        "description": "Demo page generated by MuGen Wallpaper showing a web wallpaper setup.",
        "url": "https://dreaminghk.github.io/mugenwallpaper-demo1/demo.html",
        "creator": {
          "@type": "Organization",
          "name": "MuGen Wallpaper",
          "url": "https://www.mugenwallpaper.com"
        }
      }
    </script>

    <!-- Hidden developer information: will not display in video or page UI -->
    <!--
		Source: MuGen Wallpaper demo repository
		Repo: https://github.com/dreaminghk/mugenwallpaper-demo1
		Creator: dreaminghk
		Generated: 2025-09-14
		License: Please see the original assets and MuGen Wallpaper license on https://www.mugenwallpaper.com
		Notes: Keep these comments for attribution. They are only visible in page source.
	-->
  </head>
  <body>
    <style>
      /* Local variable font: Noto Sans JP (variable weight). */
      @font-face {
        font-family: "NotoSansJPVariable";
        src: url("NotoSansJP-VariableFont_wght.ttf") format("truetype");
        font-weight: 100 900; /* variable weight range */
        font-style: normal;
        font-display: swap;
      }
      /* Make the page and #element fill the viewport with no margin/padding */
      html,
      body {
        height: 100%;
        margin: 0;
        padding: 0;
      }

      /* Use blue_sky.jpg as a full-screen responsive background while preserving aspect ratio */
      body {
        background-image: url("blue_sky.jpg");
        background-size: cover; /* scale the image to cover the viewport while keeping aspect ratio */
        background-position: center center; /* center the image */
        background-repeat: no-repeat;
        background-attachment: fixed; /* optional: keeps background fixed during scroll */
        /* fallback background color while image loads */
        background-color: #000;
      }

      /* Keep #element full viewport and transparent so background shows through */
      #element {
        width: 100vw;
        height: 100vh;
        overflow: hidden;
        display: block;
        background: transparent;
      }

      @font-face {
        font-family: 'Noto Sans JP';
        src: url('NotoSansJP-VariableFont_wght.ttf') format('truetype');
      }

      #text {
        font-family: 'Noto Sans JP', sans-serif;
        font-size: 10rem;
        color: white;
        text-shadow: 0 0 10px rgba(0,0,0,0.5);
        position: fixed;
        top: 30%;
        left: 50%;
        transform: translate(-50%, -50%);
      }

      #metrics-box {
        position: fixed;
        bottom: 20px;
        right: 20px;
        background: rgba(0, 0, 0, 0.25);
        border-radius: 10px;
        border: 1px solid rgba(255, 255, 255, 0.18);
        padding: 20px;
        color: white;
        font-family: monospace;
        backdrop-filter: blur(10px);
        -webkit-backdrop-filter: blur(10px);
      }
    </style>

    <div id="element"></div>
        <div id="text">天空</div>
    <div id="metrics-box"></div>

    <!-- Fullscreen transparent canvas for physically-inspired volumetric clouds (WebGL) -->
    <canvas id="clouds" aria-hidden="true"></canvas>
    <div
      id="mouse-coords"
      style="
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        color: white;
        font-size: 24px;
      "
    ></div>

    <script>
      // WebGL volumetric clouds: physically-inspired single-scattering with advection
      (async function () {
        const canvas = document.getElementById("clouds");
        // Request a WebGL context with alpha and without premultiplied alpha to simplify blending
        const gl = canvas.getContext("webgl", {
          alpha: true,
          antialias: true,
          premultipliedAlpha: false,
        });
        if (!gl) return; // WebGL not available

        // resize handling
        function resize() {
          // Render at reduced resolution for performance (scaled up via CSS)
          const targetDPR = 1.0; // cap device pixel ratio for speed
          const renderScale = 0.66; // render ~66% of viewport resolution for 120Hz
          const device = Math.max(1, window.devicePixelRatio || 1);
          const dpr = Math.min(device, targetDPR) * renderScale;
          const w = Math.floor(window.innerWidth * dpr);
          const h = Math.floor(window.innerHeight * dpr);
          if (canvas.width !== w || canvas.height !== h) {
            canvas.width = w;
            canvas.height = h;
            canvas.style.width = window.innerWidth + "px";
            canvas.style.height = window.innerHeight + "px";
            gl.viewport(0, 0, w, h);
          }
        }

        // Make canvas full-screen and on top of background but behind UI
        Object.assign(canvas.style, {
          position: "fixed",
          left: "0",
          top: "0",
          width: "100vw",
          height: "100vh",
          pointerEvents: "none",
          zIndex: 1,
        });
        // ensure CSS background is transparent in case user-agent paints a default
        canvas.style.background = "transparent";

        // Load shaders from external files for maintainability
        async function loadShaders() {
          const [vsResp, fsResp] = await Promise.all([
            fetch("shaders/clouds.vert.glsl"),
            fetch("shaders/clouds.frag.glsl"),
          ]);
          if (!vsResp.ok || !fsResp.ok) {
            console.error(
              "Failed to load shader files",
              vsResp.status,
              fsResp.status
            );
            return { vs: null, fs: null };
          }
          const vs = await vsResp.text();
          const fs = await fsResp.text();
          return { vs, fs };
        }

        // We'll initialize the GL program after fetching shaders
        const shaderSources = await loadShaders();
        if (!shaderSources.vs || !shaderSources.fs) return;
        const vsSource = shaderSources.vs;
        const fsSource = shaderSources.fs;

        // utility: compile shader
        function compileShader(type, source) {
          const s = gl.createShader(type);
          gl.shaderSource(s, source);
          gl.compileShader(s);
          if (!gl.getShaderParameter(s, gl.COMPILE_STATUS)) {
            console.error("Shader compile error:", gl.getShaderInfoLog(s));
            gl.deleteShader(s);
            return null;
          }
          return s;
        }

        const vs = compileShader(gl.VERTEX_SHADER, vsSource);
        const fs = compileShader(gl.FRAGMENT_SHADER, fsSource);
        const prog = gl.createProgram();
        gl.attachShader(prog, vs);
        gl.attachShader(prog, fs);
        gl.bindAttribLocation(prog, 0, "a_pos");
        gl.linkProgram(prog);
        if (!gl.getProgramParameter(prog, gl.LINK_STATUS)) {
          console.error("Program link error", gl.getProgramInfoLog(prog));
          return;
        }
        gl.useProgram(prog);
        // Enable alpha blending so clouds composite over the page background
        gl.enable(gl.BLEND);
        gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);

        // fullscreen triangle
        const quad = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, quad);
        const verts = new Float32Array([-1, -1, 3, -1, -1, 3]);
        gl.bufferData(gl.ARRAY_BUFFER, verts, gl.STATIC_DRAW);
        gl.enableVertexAttribArray(0);
        gl.vertexAttribPointer(0, 2, gl.FLOAT, false, 0, 0);

        // uniforms
        const u_time = gl.getUniformLocation(prog, "u_time");
        const u_resolution = gl.getUniformLocation(prog, "u_resolution");
        const u_wind = gl.getUniformLocation(prog, "u_wind");
        const u_sunDir = gl.getUniformLocation(prog, "u_sunDir");
        const u_sunColor = gl.getUniformLocation(prog, "u_sunColor");
        const u_coverage = gl.getUniformLocation(prog, "u_coverage");
        const u_density = gl.getUniformLocation(prog, "u_density");
        const u_thickness = gl.getUniformLocation(prog, "u_thickness");
        const u_scale = gl.getUniformLocation(prog, "u_scale");
        const u_lightAbsorption = gl.getUniformLocation(
          prog,
          "u_lightAbsorption"
        );

        let start = performance.now();

        // Default physical-ish parameters
        const params = {
          coverage: 0.55, // higher -> fewer/thinner clouds
          density: 0.9, // lower opacity overall
          thickness: 1.2, // kept for volumetric path
          scale: 0.3, // spatial scale
          lightAbsorption: 1.5, // volumetric path only
        };

        function sunDirection(t) {
          // Slow cycle of sun over time; keep moderately high to avoid dark scene
          const floatTime = t * 0.02;
          const elev = 0.8 - 0.15 * Math.cos(floatTime * 0.2); // radians
          const azim = floatTime * 0.05;
          const x = Math.cos(elev) * Math.cos(azim);
          const y = Math.sin(elev);
          const z = Math.cos(elev) * Math.sin(azim);
          // Return vector from sun toward scene (downward)
          return [-x, -y, -z];
        }

        // Optional lightweight FPS cap to reduce GPU usage
        const targetFPS = 0; // 0 = unlimited (use monitor refresh)
        const minFrameTime = targetFPS > 0 ? 1.0 / targetFPS : 0.0;
        let lastRenderT = 0;

        function render() {
          resize();
          const now = performance.now();
          const t = (now - start) / 1000.0;
          if (minFrameTime > 0.0 && t - lastRenderT < minFrameTime) {
            requestAnimationFrame(render);
            return;
          }
          gl.clearColor(0, 0, 0, 0);
          gl.clear(gl.COLOR_BUFFER_BIT);
          gl.useProgram(prog);
          gl.uniform1f(u_time, t);
          gl.uniform2f(u_resolution, canvas.width, canvas.height);
          // Gentle varying wind with slight rotation over time
          // Use a stable, gentle wind to avoid "wavy" look
          const windSpeed = 0.006; // world units per second
          const windDir = [0.7, 0.2];
          const len = Math.hypot(windDir[0], windDir[1]) || 1.0;
          gl.uniform2f(
            u_wind,
            (windDir[0] / len) * windSpeed,
            (windDir[1] / len) * windSpeed
          );

          const sd = sunDirection(t);
          gl.uniform3f(u_sunDir, sd[0], sd[1], sd[2]);
          gl.uniform3f(u_sunColor, 1.0, 0.97, 0.92); // warm sunlight
          gl.uniform1f(u_coverage, params.coverage);
          gl.uniform1f(u_density, params.density);
          gl.uniform1f(u_thickness, params.thickness);
          gl.uniform1f(u_scale, params.scale);
          gl.uniform1f(u_lightAbsorption, params.lightAbsorption);
          gl.drawArrays(gl.TRIANGLES, 0, 3);
          lastRenderT = t;
          requestAnimationFrame(render);
        }

        // start
        resize();
        window.addEventListener("resize", resize);
        requestAnimationFrame(render);
      })();

      // Mouse coordinates
      const mouseCoordsDiv = document.getElementById("mouse-coords");
      window.addEventListener("mousemove", (event) => {
        const { clientX, clientY } = event;
        mouseCoordsDiv.textContent = `X: ${clientX}, Y: ${clientY}`;
      });
    </script>

    <div id="clock">
      <div class="clock-backdrop"></div>
      <svg
        class="svg-mask"
        width="100%"
        height="100%"
        preserveAspectRatio="none"
      >
        <mask id="frostyGlassMask">
          <rect width="100%" height="100%" fill="white" rx="10" ry="10" />
        </mask>
      </svg>
      <div id="location-display"></div>
      <div id="date-display"></div>
      <div id="clock-content-wrapper"></div>
      <div id="metrics-display"></div>
    </div>
    <style>
      #clock {
        position: absolute;
        top: 50%;
        left: 50%;
        top: 70%;
        transform: translate(-50%, -50%);
        padding: 20px;
      }
      #clock-content-wrapper {
        position: relative;
        color: white;
        font-size: 72px;
        font-family: "NotoSansJPVariable", system-ui, -apple-system, "Segoe UI",
          Roboto, "Helvetica Neue", Arial, "Noto Sans JP", "Noto Sans",
          sans-serif;
        padding-top: 40px;
      }
      .ampm-text {
        font-size: 36px;
      }
      .clock-backdrop {
        position: absolute;
        inset: 0;
        height: 200%;
        backdrop-filter: blur(16px);
        -webkit-backdrop-filter: blur(16px);
        mask-image: url(#frostyGlassMask);
        -webkit-mask-image: url(#frostyGlassMask);
        pointer-events: none;
      }
      .svg-mask {
        position: absolute;
        inset: 0;
        pointer-events: none;
      }
      #location-display {
        position: absolute;
        top: 20px;
        left: 20px;
        color: white;
        font-family: "NotoSansJPVariable", system-ui, -apple-system, "Segoe UI",
          Roboto, "Helvetica Neue", Arial, "Noto Sans JP", "Noto Sans",
          sans-serif;
        font-size: 16px;
      }
      #date-display {
        position: absolute;
        top: 20px;
        right: 20px;
        color: white;
        font-family: "NotoSansJPVariable", system-ui, -apple-system, "Segoe UI",
          Roboto, "Helvetica Neue", Arial, "Noto Sans JP", "Noto Sans",
          sans-serif;
        font-size: 16px;
      }
      #metrics-display {
        position: absolute;
        bottom: 20px;
        left: 20px;
        color: white;
        font-family: monospace;
        font-size: 12px;
      }
    </style>
    <script>
      document.addEventListener("DOMContentLoaded", function () {
        function updateClock() {
          const now = new Date();
          const hours = now.getHours().toString().padStart(2, "0");
          const minutes = now.getMinutes().toString().padStart(2, "0");
          const seconds = now.getSeconds().toString().padStart(2, "0");
          const ampm = now.getHours() >= 12 ? "PM" : "AM";
          document.getElementById(
            "clock-content-wrapper"
          ).innerHTML = `${hours}:${minutes}:${seconds} <span class="ampm-text">${ampm}</span>`;
        }
        setInterval(updateClock, 1000);

        function updateDateAndLocation() {
          const now = new Date();
          const day = now.getDate().toString().padStart(2, "0");
          const month = (now.getMonth() + 1).toString().padStart(2, "0");
          const year = now.getFullYear().toString().slice(-2);
          document.getElementById(
            "date-display"
          ).textContent = `${day}/${month}/${year}`;

          let timeZone = Intl.DateTimeFormat()
            .resolvedOptions()
            .timeZone.replace(/_/g, " ");
          if (timeZone.includes("/")) {
            timeZone = timeZone.split("/")[1];
          }
          document.getElementById("location-display").textContent = timeZone;
        }
        updateDateAndLocation();
        updateClock();

        const metricsDisplay = document.getElementById('metrics-display');
        window.addEventListener('nativeMetrics', (event) => {
          const { cpu, memory, disk, network } = event.detail;
          metricsDisplay.innerHTML = `
            <strong>CPU:</strong> ${cpu.totalPercent.toFixed(2)}%<br>
            <strong>Mem:</strong> ${(memory.usedBytes / 1024 / 1024 / 1024).toFixed(2)}GB / ${(memory.totalBytes / 1024 / 1024 / 1024).toFixed(2)}GB<br>
            <strong>Disk:</strong> ${(disk.freeBytes / 1024 / 1024 / 1024).toFixed(2)}GB free<br>
            <strong>Net:</strong> DL: ${(network.rxBytesPerSec / 1024).toFixed(2)}KB/s, UL: ${(network.txBytesPerSec / 1024).toFixed(2)}KB/s
          `;
        });
      });
    </script>
  </body>
</html>
